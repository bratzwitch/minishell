#include "../include/minishell.h"

// this data type ensures that the variable can be safely read and written even in the presence of asynchronous signals.
//      The volatile keyword is used to inform the compiler that a variable's value may change at any time,
//      without any action being taken by the code the compiler finds nearby. (+ The compiler might optimize away reads and writes to variables if it assumes their values do not change unexpectedly.)

/* Asynchronous signals are events that can occur at any time, interrupting the normal flow of a program.
These signals are typically generated by external events or by the operating system. Examples:
SIGINT: Interrupt signal (e.g., from pressing Ctrl+C).
SIGTERM: Termination signal.
SIGALRM: Alarm clock signal.
SIGCHLD: Child process terminated or stopped. */

/* Normal Command Exit:
0: Command executed successfully.
1â€“125: Command failed for various reasons.

Special Signal Exit:
128 + SIGNAL_NUMBER: Indicates the process was terminated by a signal.
Example: 130 for SIGINT (128 + 2).

Shell Exit Codes:
126: Command found but not executable.
127: Command not found. */

void sig_handler(int signum)
{
    received_sig = 128 + signum;
    rl_replace_line("", 0);
    rl_on_new_line();
    write(STDOUT_FILENO, "\n", 1);
    rl_redisplay();
}

void setup_handlers(void)
{
    struct sigaction sa;

    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sa.sa_handler = sig_handler;
    if (sigaction(SIGINT, &sa, NULL) == -1)
    {
        write(STDERR_FILENO, "Error: sigaction SIGINT\n", 25);
        exit(1);
    }
    if (sigaction(SIGCHLD, &sa, NULL) == -1)
    {
        write(STDERR_FILENO, "Error: sigaction SIGCHLD\n", 26);
        exit(1);
    }
    sa.sa_handler = SIG_IGN;
    if (sigaction(SIGQUIT, &sa, NULL) == -1)
    {
        write(STDERR_FILENO, "Error: sigaction SIGQUIT\n", 26);
        exit(1);
    }
}
